{
    "version": "https://jsonfeed.org/version/1",
    "title": "只想摆烂，阿巴阿巴阿巴",
    "subtitle": "",
    "icon": "https://zhiyuan-porg.github.io/assets/favicon.ico",
    "description": "",
    "home_page_url": "https://zhiyuan-porg.github.io",
    "items": [
        {
            "id": "https://zhiyuan-porg.github.io/2024/09/19/MySQL%E5%91%BD%E4%BB%A4%E3%80%81%E6%97%A5%E5%BF%97%E5%8F%8A%E9%9B%86%E7%BE%A4/",
            "url": "https://zhiyuan-porg.github.io/2024/09/19/MySQL%E5%91%BD%E4%BB%A4%E3%80%81%E6%97%A5%E5%BF%97%E5%8F%8A%E9%9B%86%E7%BE%A4/",
            "title": "日志、分表及集群",
            "date_published": "2024-09-19T10:27:45.583Z",
            "content_html": "<h2 id=\"1mysql日志\"><a class=\"anchor\" href=\"#1mysql日志\">#</a> 1.MySQL 日志</h2>\n<h3 id=\"11二进制日志\"><a class=\"anchor\" href=\"#11二进制日志\">#</a> 1.1. 二进制日志</h3>\n<p>​\t在 MySQL 中，二进制日志可以记录数据库的变更操作，比如增加、删除、修改等操作，但并不会记录查询相关的操作（select、show、explain、desc 等）。借助这一特性，二进制日志可以用于数据恢复、主从复制等操作中。其中，二进制数据又分为 SBR、RBR、MBR 三种类型。</p>\n<p>**SBR: ** 记录对数据库数据进行变更的操作的原生的 SQL 语句</p>\n<blockquote>\n<p>** 优点：** 当一个 SQL 语句修改多行数据时，只需要记录一条 SQL 语句，binlog 的所需占用的存储容量比较小，节约 IO，提升日志记录性能</p>\n<p>** 缺点： ** 当原生的 SQL 语句中含有诸如 now ()、uuid 等不确定的数据时会导致数据不一致的问题，也就是再次执行这条 SQL 语句，并不能复现 now ()、uuid 等不确定值。</p>\n</blockquote>\n<p><strong>RBR:</strong> 记录数据变更前和变更后的对比</p>\n<blockquote>\n<p><strong>优点：</strong> 如果 SQL 语句中含有诸如 now ()、uuid 等这类不确定的数值时，日志中记录的是执行该 SQL 后所生成的确定的值，保证了数据的一致性</p>\n<p>** 缺点： ** 当一个 SQL 语句修改多行数据时，日志会详细地记录每一行的修改，binlog 日志暴涨</p>\n</blockquote>\n<p><strong>MBR：</strong> 综合了 SBR 和 RBR 的优点，在一般情况下用 SBR 记录日志，当 SQL 语句中含有 now ()、uuid 等不确定的数据时采用 RBR 记录日志。这种方式既减少了日志量，又可以保证数据的一致性。</p>\n<h3 id=\"12查询日志\"><a class=\"anchor\" href=\"#12查询日志\">#</a> 1.2. 查询日志</h3>\n<p>​\t在 MySQL 中还存在查询日志，与二进制日志只记录对数据库的变更操作不同，它记录了 MySQL 接收到的所有 SQL 命令，即包括增删改查，又包括客户端连接及断等详细信息。</p>\n<h3 id=\"13慢查询日志\"><a class=\"anchor\" href=\"#13慢查询日志\">#</a> 1.3. 慢查询日志</h3>\n<p>​\t在 MySQL 中存在一个系统变量 <strong>long_query_time（默认是 10 秒）</strong>，当执行的 SQL 语句超过这个阈值时，就会被定义为慢查询语句，然后存入慢查询日志中。慢查询日志的所存在的意义，就是收集那些执行时间相对较长的 SQL 语句，便于单独优化以提升系统性能。</p>\n<h2 id=\"2表拆分\"><a class=\"anchor\" href=\"#2表拆分\">#</a> 2. 表拆分</h2>\n<p>​\t对于千万级数据量的数据库，应用常规的优化手段过后，仍然存在性能瓶颈。此时我可以采用分表的方式，减少一次查询的数据量以提升性能。对于表的拆分方式，又有<strong>水平分表</strong>和<strong>垂直分表</strong>两种，且各有利弊。</p>\n<p><strong>水平分表：</strong>  是对数据行的拆分，按照某种规则（比如 % 操作）将一个大表拆分成若干的小表。这种方式看起来更像是一种数据归档分类操作，比如将一些数据按照年份、月份、地区等划分。但其弊端就是在业务层的逻辑处理较为繁琐，需要参照拟定的分表规则以正确无误得操作指定的数据表。</p>\n<blockquote>\n<p>** 注：** 水平分表的操作看起来和数据分区十分相似，其实两之间还是有比较大的区别的。</p>\n<p><strong>数据分区</strong>（也称为表分区）是将表中的数据逻辑上划分为多个部分，每个部分称为一个分区，而物理上这些分区可能存储在不同的磁盘或服务器上。分区可以是基于范围、列表、哈希或复合方法。数据分区的优点包括提高查询效率、简化数据维护、更好的空间管理和并发控制。然而，分区也增加了复杂性，可能导致性能下降，并且不适用于所有场景。</p>\n<p><strong>区别</strong>：</p>\n<ol>\n<li><strong>目标</strong>：水平分表通常是为了解决单表数据量过大的问题，而数据分区则是为了提高查询性能和管理大型表。</li>\n<li><strong>方法</strong>：水平分表是通过创建多个结构相同的表来实现，数据分区是在单个表内部创建多个分区。</li>\n<li><strong>透明性</strong>：分区对于应用程序来说是透明的，而分表可能需要应用程序知道数据分布的逻辑。</li>\n<li><strong>数据关联性</strong>：分区表内的数据保持完整的关联性，可以进行全表扫描和 JOIN 操作；分表后跨表 JOIN 操作复杂。</li>\n</ol>\n<p><strong>优点</strong>：</p>\n<ul>\n<li><strong>水平分表</strong>：提高查询性能，简化数据管理，支持分布式处理。</li>\n<li><strong>数据分区</strong>：提高查询效率，简化数据维护，更好的空间管理，提高并发性能。</li>\n</ul>\n<p><strong>缺点</strong>：</p>\n<ul>\n<li><strong>水平分表</strong>：连接操作复杂，数据一致性难以保证，分布式事务问题。</li>\n<li><strong>数据分区</strong>：增加复杂性，性能下降风险，不适用于所有场景，分区键选择关键。</li>\n</ul>\n</blockquote>\n<p><strong>垂直分表：</strong> 对于数据量不大，但字段很多的数据表，其中也包含了一些访问频率不高的字段，但在检索时却还要检索这些冗余的数据，大大降低的 IO 的性能。此时，我们可以将表按照字段进拆分，以提高的其效率。但当要查询到⼀些主表上没有的列，必须使⽤关联查询来检索数据，提⾼了复杂性并且降低了⼀定的性能</p>\n<blockquote>\n<p><strong>注：</strong> 拆分后的表之间是一对一的关系</p>\n</blockquote>\n<p>垂直分表的相关规则：</p>\n<p>​\t把不常⽤的字段单独放在⼀张表</p>\n<p>​\t较⼤的列单独拆分出来</p>\n<p>​\t经常组合查询的列放在⼀张表中</p>\n<p>​\t所有拆分的表都建⽴外键与主表关联</p>\n<p>##3.MySQL 集群</p>\n<h3 id=\"31-读写分离架构\"><a class=\"anchor\" href=\"#31-读写分离架构\">#</a> 3.1 . 读写分离架构</h3>\n<p>​\tMySQL 读写分离架构是一种常见的数据库架构，用于提高数据库的读取性能和吞吐量。在这种架构中，通常有一个主数据库（Master）负责处理写操作（如 INSERT、UPDATE、DELETE），以及一个或多个从数据库（Slaves）负责处理读操作（如 SELECT）。这种架构的目的是将读写负载分散到多个服务器，以此来提高性能和可用性。</p>\n<p><strong>实现读写分离的方式主要有以下几种：</strong></p>\n<ol>\n<li>\n<p><strong>应用程序层实现</strong>：在应用程序代码中，根据执行的操作类型（读或写），手动指定使用主数据库还是从数据库。这种方式简单易实现，但当架构调整时，可能需要修改代码，且难以实现高级功能，如自动分库、分表等。</p>\n</li>\n<li>\n<p><strong>中间件实现</strong>：使用数据库代理中间件，如 MySQL Proxy、Atlas、MyCat 等，来自动进行读写分离。中间件位于应用程序和数据库服务器之间，根据配置的规则将请求路由到合适的数据库服务器。这种方式的优点是架构设计更灵活，可以实现更高级的控制，如透明化水平拆分、故障转移、监控等，且对业务代码的影响小。</p>\n</li>\n<li>\n<p><strong>MySQL Connector/J</strong>：使用 MySQL 的 JDBC 驱动程序实现读写分离。在配置 JDBC 连接字符串时，指定主库和从库的地址，驱动程序会根据查询类型自动将请求路由到正确的数据库服务器。</p>\n</li>\n<li>\n<p><strong>Sharding-JDBC</strong>：使用 ShardingSphere 提供的 Sharding-JDBC 实现读写分离。Sharding-JDBC 是一个客户端的分片中间件，它提供了读写分离和分库分表的功能。</p>\n</li>\n</ol>\n<p><strong>读写分离的优点包括：</strong></p>\n<ul>\n<li>提高读取性能：通过将读取负载分散到多个从服务器，可以显著提高查询性能。</li>\n<li>降低主服务器的压力：写操作集中在主服务器上，读操作分散到从服务器，减轻了主服务器的负担。</li>\n<li>提高数据可用性：即使主服务器发生故障，从服务器仍然可以提供读取服务。</li>\n</ul>\n<p><strong>读写分离的缺点包括：</strong></p>\n<ul>\n<li>数据延迟：从服务器的数据可能会因为复制延迟而不实时。</li>\n<li>复杂性增加：需要管理多个数据库服务器和处理数据同步的问题。</li>\n<li>事务处理复杂：跨服务器的事务处理会变得复杂。</li>\n</ul>\n<p>在实施读写分离时，还需要考虑数据同步的方式，如基于二进制日志的异步复制或基于 GTID 的同步复制，以及如何确保数据的一致性和系统的高可用性。</p>\n<h3 id=\"32mysql主从复制\"><a class=\"anchor\" href=\"#32mysql主从复制\">#</a> 3.2.MySQL 主从复制</h3>\n<p><strong>MySQL 主从复制的原理：</strong></p>\n<p>​\tmaster 将数据改变记录到⼆进制⽇志 (binary log) 中</p>\n<p>​\tslave 将 master 的 binary log events 拷⻉到它的中继⽇志 (relay log)</p>\n<p>​\tslave 读取中继⽇志中的数据实现数据的恢复</p>\n<p><strong>MySQL 主从复制的条件：</strong></p>\n<p>​\t Master 与 Slave 的数据库版本必须⼀致</p>\n<p>​\tMaster 与 Slave 在开始建⽴主从复制时的数据必须⼀致</p>\n<p>​\tMaster 必须开启⼆进制⽇志，Master 与 Slave 的 server_id 必须都唯⼀</p>\n<p>​\tMaster 与 Slave 的 server-uuid（在 /var/lib/mysql/auto.cnf  ⽂件中保存）不能相同</p>\n",
            "tags": []
        },
        {
            "id": "https://zhiyuan-porg.github.io/2024/07/23/JSP-MVC/",
            "url": "https://zhiyuan-porg.github.io/2024/07/23/JSP-MVC/",
            "title": "JSP-MVC",
            "date_published": "2024-07-23T02:01:03.249Z",
            "content_html": "<h2 id=\"jsp-mvc\"><a class=\"anchor\" href=\"#jsp-mvc\">#</a> JSP-MVC</h2>\n<h2 id=\"1jsp\"><a class=\"anchor\" href=\"#1jsp\">#</a> 1.JSP</h2>\n<h3 id=\"11html和servelet的弊端\"><a class=\"anchor\" href=\"#11html和servelet的弊端\">#</a> 1.1.HTML 和 Servelet 的弊端</h3>\n<p>​\t<strong>HTML：</strong></p>\n<p>​\t优点：方便页面的布局及美化</p>\n<p>​\t缺点：不能制作动态内容</p>\n<p>​\t<strong>Servlet：</strong></p>\n<p>​\t优点：可以制作动态内容</p>\n<pre><code>缺点：不方便写CSS和JS代码\n</code></pre>\n<blockquote>\n<p>二者的优缺点刚好互补，两者综合起来就刚刚好是 JSP 的设计思想</p>\n</blockquote>\n<h3 id=\"12jsp简介\"><a class=\"anchor\" href=\"#12jsp简介\">#</a> 1.2.JSP 简介</h3>\n<p>​\t以 Java 作为脚本语言，部署在网络服务器上，可以根据客户端的请求内容动态生成 HTML、XML 或其他格式文档的 Web 网页，然后返回给请求者。另外，JSP 的标签库 JSTL 提供了类似于 Java 中的 if、switch、for 等功能，开发者可以更方便地实现条件渲染和列表渲染等操作，而且也不受跨平台的限制。</p>\n<blockquote>\n<p>**Tips：**JSP 编译器可以将 JSP 文件编译成用 Java 代码写的 Servlet，然后 Servlet 再编译生成字节码文件。JSP 本质上就是一个 Servlet，属于动态技术。</p>\n</blockquote>\n<h3 id=\"13jsp语法\"><a class=\"anchor\" href=\"#13jsp语法\">#</a> 1.3.JSP 语法</h3>\n<h4 id=\"131输出脚本\"><a class=\"anchor\" href=\"#131输出脚本\">#</a> 1.3.1. 输出脚本</h4>\n<p>​\t<strong>作用：</strong> 直接输出变量值或对表达式进行计算</p>\n<pre><code class=\"language-jsp\">&lt;%= 变量名称或表达式%&gt;  // 相当于Servlet的out.print()\n</code></pre>\n<h4 id=\"132声明\"><a class=\"anchor\" href=\"#132声明\">#</a> 1.3.2. 声明</h4>\n<pre><code>**作用：** 声明全局变量或方法\n</code></pre>\n<pre><code class=\"language-jsp\">&lt;%! 全局变量或方法 %&gt;\n</code></pre>\n<h4 id=\"133插入代码片段\"><a class=\"anchor\" href=\"#133插入代码片段\">#</a> 1.3.3. 插入代码片段</h4>\n<pre><code>**作用：** 插入Java代码\n</code></pre>\n<pre><code class=\"language-jsp\">&lt;% Java代码 %&gt; \n</code></pre>\n<h3 id=\"14jsp九大内置对象\"><a class=\"anchor\" href=\"#14jsp九大内置对象\">#</a> 1.4.JSP 九大内置对象</h3>\n<p>​\t<strong>PageContext:</strong> 页面域</p>\n<p>​\t<strong>Request：</strong> HttpServletRequest (请求域)</p>\n<p>​\t<strong>Session：</strong> 会话域</p>\n<p>​\t<strong>Application：</strong> 上下文域</p>\n<blockquote>\n<p>以上为四大域对象， 从大到小依次为 Application &gt; Session &gt; Request &gt; PageContext</p>\n<p><strong>相关的方法：</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">作用域</th>\n<th style=\"text-align:center\">Java 代码</th>\n<th style=\"text-align:center\">EL 的写法</th>\n<th style=\"text-align:center\">范围大小</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">页面域</td>\n<td style=\"text-align:center\">&lt;% = pageContext.getAttribute (&quot;键名&quot;) %&gt;</td>\n<td style=\"text-align:center\" pageScope.键名=\"\">$</td>\n<td style=\"text-align:center\">1</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">请求域</td>\n<td style=\"text-align:center\">&lt;% = request.getAttribute (&quot;键名&quot;) %&gt;</td>\n<td style=\"text-align:center\" requestScope.键名=\"\">$</td>\n<td style=\"text-align:center\">2</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">会话域</td>\n<td style=\"text-align:center\">&lt;% = session.getAttribute (&quot;键名&quot;) %&gt;</td>\n<td style=\"text-align:center\" sessionScope.键名=\"\">$</td>\n<td style=\"text-align:center\">3</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">上下文域</td>\n<td style=\"text-align:center\">&lt;% = application.getAttribute (&quot;键名&quot;) %&gt;</td>\n<td style=\"text-align:center\" applicationScope.键名=\"\">$</td>\n<td style=\"text-align:center\">4</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">自动查找</td>\n<td style=\"text-align:center\">&lt;% = pageContext.findAttribute (&quot;键名&quot;) %&gt;</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n</tr>\n</tbody>\n</table>\n</blockquote>\n<p>​\t<strong>Response：</strong> HttpServletResponse</p>\n<p>​\t<strong>Out</strong></p>\n<p>​\t<strong>Config：</strong> ServletConfig</p>\n<p>​\t<strong>Page:</strong> 当前页面的引用，就是 this</p>\n<p>​\t<strong>Exception：</strong> 封装了出现的异常， 只有在错误页面的中才会存在</p>\n<h4 id=\"141pagecontext域\"><a class=\"anchor\" href=\"#141pagecontext域\">#</a> 1.4.1PageContext 域</h4>\n<p>​\tPageContext 域是 servlet 中 4 个域对象中最后一个了，而且大小也是<strong>最小的</strong>，只在当前页面下生效，且在不同的页面下不能实现页面共享（即使是一次请求）</p>\n<p>​\t有关的方法：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">方法</th>\n<th style=\"text-align:center\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">void setAttribute(String key, Object value)</td>\n<td style=\"text-align:center\">向页面域中添加键和值</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Object getAttribute(String key)</td>\n<td style=\"text-align:center\">从页面域中得到值</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">void removeAttribute(String key)</td>\n<td style=\"text-align:center\">删除页面域中键值对</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Object findAttribute(String key)</td>\n<td style=\"text-align:center\">自动从四个作用域中去查某个键，从小到大的范围来查找，如果找到就停止。如果没有找到，返回 null，<strong>该方法是页面域独有的</strong></td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"142exception对象\"><a class=\"anchor\" href=\"#142exception对象\">#</a> 1.4.2Exception 对象</h4>\n<p>​\t<strong>Exception 属于 JSP 的九大内置对象，但是只有错误页面才会生成该对象，普通的 JSP 页面不会存在 Exception 对象</strong></p>\n<blockquote>\n<p>​\t<strong>warning：</strong></p>\n<p>​\t(1) 当前页面只有设置了 <strong>isErrorPage = true</strong> 时才可以使用 exception 内置对象</p>\n<p>​\t(2) 常规页面只有八大内置对象，只有错误页面才有九大内置对象</p>\n</blockquote>\n<h2 id=\"2el表达式\"><a class=\"anchor\" href=\"#2el表达式\">#</a> 2.EL 表达式</h2>\n<p>​\t<strong>语法</strong></p>\n<pre><code class=\"language-jsp\">$&#123; 变量名或表达式&#125;\n</code></pre>\n<h3 id=\"21食用说明\"><a class=\"anchor\" href=\"#21食用说明\">#</a> 2.1. 食用说明</h3>\n<p>​\t<strong>变量名：</strong> 变量名即可以是诸如 x, y, z 这样的普通变量，也可以是 Object、List、Map、数组或者 JavaBean 等</p>\n<blockquote map[xiaoshabi]=\"\">\n<p>Tips: 键名中如果有特殊字符时，可以使用双引号或者单引号将其引起来。 e.g. $</p>\n</blockquote>\n<p>​\t<strong>表达式：</strong> EL 表达式中的表达式可以包含常规的算术表达式（ + 、 - 、* 、/ 、%）、比较表达式（ == 、 != 、&lt;、&lt;=、&gt; 、&gt;=）、逻辑表达式（&amp;&amp; 、|| 、！）、三元运算以及判空表达式（${ empty 变量名}）</p>\n<h2 id=\"3jstl标签库\"><a class=\"anchor\" href=\"#3jstl标签库\">#</a> 3.JSTL 标签库</h2>\n<p>​\t使用时先导入 jar 包</p>\n<h3 id=\"31相关标签\"><a class=\"anchor\" href=\"#31相关标签\">#</a> 3.1 相关标签</h3>\n<p>**&lt;c:if test=&quot;条件判断表达式&quot;&gt; ** 条件判断</p>\n<p><strong>&lt;c:choose&gt;</strong> 多分支判断</p>\n<blockquote>\n<p><strong>类似于 switch，层级结构为：</strong></p>\n<pre><code class=\"language-jsp\">&lt;c:choose&gt;\n    &lt;c:when test = &quot;条件表达式&quot;&gt;\n   \t \txxxxxxxx\n    &lt;/c:when&gt;\n    //默认条件，相当于default\n    &lt;c:otherwise&gt;\n        xxxxxxx\n    &lt;/c:otherwise&gt;\n&lt;/c:choose\n</code></pre>\n</blockquote>\n<p><strong>&lt;c:forEach&gt;</strong> 循环渲染</p>\n<blockquote>\n<p><strong>类似于 for 语句，相关的参数有</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">属性名</th>\n<th style=\"text-align:center\">EL 支持</th>\n<th style=\"text-align:center\">类型</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">items</td>\n<td style=\"text-align:center\">true</td>\n<td style=\"text-align:center\">数组或集合</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">var</td>\n<td style=\"text-align:center\">false</td>\n<td style=\"text-align:center\">String</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">varStatus</td>\n<td style=\"text-align:center\">false</td>\n<td style=\"text-align:center\">String</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">begin</td>\n<td style=\"text-align:center\">true</td>\n<td style=\"text-align:center\">int</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">end</td>\n<td style=\"text-align:center\">true</td>\n<td style=\"text-align:center\">int</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">step</td>\n<td style=\"text-align:center\">true</td>\n<td style=\"text-align:center\">int</td>\n</tr>\n</tbody>\n</table>\n<p>其中<strong> varStatus</strong> 还有一些子属性（虽然也不是很常用）</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">属性</th>\n<th style=\"text-align:center\">数据类型</th>\n<th style=\"text-align:center\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">index</td>\n<td style=\"text-align:center\">int</td>\n<td style=\"text-align:center\">当前元素的索引号，从 0 开始</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">count</td>\n<td style=\"text-align:center\">int</td>\n<td style=\"text-align:center\">遍历到当前位置，一共遍历了多少个元素（默认从 1 开始）</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">first</td>\n<td style=\"text-align:center\">boolean</td>\n<td style=\"text-align:center\">如果当前遍历的是第 1 个元素，则返回 true</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">last</td>\n<td style=\"text-align:center\">boolean</td>\n<td style=\"text-align:center\">如果当前遍历的是最后 1 个元素，则返回 true</td>\n</tr>\n</tbody>\n</table>\n</blockquote>\n<h2 id=\"4三层架构-and-mvc\"><a class=\"anchor\" href=\"#4三层架构-and-mvc\">#</a> 4. 三层架构 And MVC</h2>\n<h3 id=\"41三层架构\"><a class=\"anchor\" href=\"#41三层架构\">#</a> 4.1. 三层架构</h3>\n<p>三层架构（Three-Tier Architecture）和 MVC（Model-View-Controller）是两种常见的软件设计模式，它们用于构建可维护、可扩展和模块化的应用程序。</p>\n<p>三层架构是一种分层的客户端 - 服务器架构，它将应用程序分为三个逻辑层次：</p>\n<ol>\n<li>\n<p><strong>表示层（Presentation Layer）</strong>：这一层处理用户界面和用户交互。它负责接收用户的输入，调用业务逻辑层来处理数据，并显示信息给用户。</p>\n</li>\n<li>\n<p><strong>业务逻辑层（Business Logic Layer）</strong>：也称为中间层或服务层，它包含应用程序的业务规则和逻辑。这一层处理数据的加工和计算，如数据库操作、数值计算等。</p>\n</li>\n<li>\n<p><strong>数据访问层（Data Access Layer）</strong>：这一层负责数据持久化，包括数据的读取、写入和更新。它通常与数据库交互，执行 CRUD（创建、读取、更新、删除）操作。</p>\n</li>\n</ol>\n<p>三层架构的优点包括：</p>\n<ul>\n<li><strong>分离关注点</strong>：每一层都有其特定的职责，这有助于分离关注点，使得开发和维护更加容易。</li>\n<li><strong>可维护性</strong>：每一层可以独立开发和测试，提高了代码的可维护性。</li>\n<li><strong>可扩展性</strong>：可以根据需要扩展任何一层，而不会影响到其他层。</li>\n</ul>\n<h3 id=\"42mvc\"><a class=\"anchor\" href=\"#42mvc\">#</a> 4.2.MVC</h3>\n<p>MVC 是一种设计模式，用于实现用户界面的分离。它将应用程序分为三个主要组件：</p>\n<ol>\n<li>\n<p><strong>模型（Model）</strong>：代表应用程序的数据和业务逻辑。模型负责处理数据和业务规则。</p>\n</li>\n<li>\n<p><strong>视图（View）</strong>：代表用户界面。视图负责显示数据（模型）和接收用户输入。</p>\n</li>\n<li>\n<p><strong>控制器（Controller）</strong>：作为模型和视图之间的中介。控制器接收用户的输入，调用模型处理数据，然后选择合适的视图显示结果。</p>\n</li>\n</ol>\n<p>MVC 的优点包括：</p>\n<ul>\n<li><strong>分离关注点</strong>：MVC 通过将数据（模型）、用户界面（视图）和业务逻辑（控制器）分离，使得开发和维护更加清晰。</li>\n<li><strong>可维护性</strong>：由于关注点的分离，MVC 使得代码更加模块化，易于维护和测试。</li>\n<li><strong>可重用性</strong>：模型和视图可以独立于控制器重用，提高了代码的重用性。</li>\n</ul>\n<h3 id=\"43三层架构与mvc的关系\"><a class=\"anchor\" href=\"#43三层架构与mvc的关系\">#</a> 4.3. 三层架构与 MVC 的关系</h3>\n<p>三层架构和 MVC 可以结合使用。在这种结合中：</p>\n<ul>\n<li><strong>表示层</strong>通常包含 MVC 的视图和控制器。视图负责显示数据，控制器处理用户输入和调用业务逻辑层。</li>\n<li><strong>业务逻辑层</strong>对应于 MVC 的模型，处理应用程序的核心逻辑。</li>\n<li><strong>数据访问层</strong>通常不直接包含在 MVC 中，但它为模型提供数据持久化的支持。</li>\n</ul>\n<p>通过将三层架构与 MVC 结合，可以构建一个结构清晰、易于维护和扩展的应用程序。</p>\n",
            "tags": []
        }
    ]
}