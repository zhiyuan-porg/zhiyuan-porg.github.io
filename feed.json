{
    "version": "https://jsonfeed.org/version/1",
    "title": "遇到困难了怎么办，睡一觉就好了",
    "subtitle": "",
    "icon": "https://zhiyuan-porg.github.io/assets/favicon.ico",
    "description": "",
    "home_page_url": "https://zhiyuan-porg.github.io",
    "items": [
        {
            "id": "https://zhiyuan-porg.github.io/2024/09/24/Undo%20Log%E6%97%A5%E5%BF%97/",
            "url": "https://zhiyuan-porg.github.io/2024/09/24/Undo%20Log%E6%97%A5%E5%BF%97/",
            "title": "",
            "date_published": "2024-09-24T10:59:01.676Z",
            "content_html": "<hr />\n<h2 id=\"title浅谈undo-log日志\"><a class=\"anchor\" href=\"#title浅谈undo-log日志\">#</a> title: 浅谈 Undo Log 日志</h2>\n<h1 id=\"谈谈undo-log日志\"><a class=\"anchor\" href=\"#谈谈undo-log日志\">#</a> 谈谈 Undo Log 日志？</h1>\n<p>​\t在 MySQL 的所有引擎中，只有 InnoDB 引擎支持事务，而 undo log 正是 InnoDB 存储引擎用于实现事务原子性和一致性的关键机制。其中，原子性是指在一个事务内的对数据库的任何更改操作要么全部成功，要么在执行过程中发生错误或者异常时视为全部失败，将数据状态还原。而一致性是指事务执行前后，数据库中数据应保持相同的状态。以转账操作为例，用户 A 向用户 B 转账，正常的逻辑是 A 减少金额等于 B 增加金额，但如果在 A 减少金额成功后出现了异常终止了接下来的增加 B 用户余额的操作，此时如果不撤销对 A 减少金额的操作将会导致此事务执行前后 AB 用户余额总量之和不一致。而要对事务中的行为的进行撤销（回滚），则恰恰要以 undo log 日志中的内容为依据。</p>\n<p>​\tundo log 是一种逻辑日志，它可以记录事务对数据库所做的更改的相反操作，主要包含了执行变更操作的事务 ID、回滚指针、数据行的旧值、聚集索引、删除标记等信息。其中操作类型分为两种: insert 类型和 update 类型。</p>\n<p>​\t对于 insert 类型的操作，它的相反操作是 delete 操作。进行 insert 操作时，将本次事务的 id 以及插入的数据写入 undo log 中，且回退的版本号为 null。当事务回滚时，事务中的 insert 操作将视为全部失败，然后将已插入的数据执行 delete 逻辑删除操作。</p>\n<p>​\t对于 update 类型的操作，又分为 update 和 delete 操作（修改了隐藏列的标记值）。进行 update 操作时，先将旧数据写入 undo log 中，后将 ibd 文件中数据行中的本次事务 id 设为本次事务 id，回滚指针则设置为旧数据中的事务 id，然后更新数据行中的数据。当在一个时间间隔内有多个事务对同一条记录进行修改时，undo log 中就会形成修改版本链。进行 delete 操作时，也是旧数据写入 undo log 中，后将 ibd 文件中数据行中的本次事务 id 设为本次事务 id，回滚指针则设置为旧数据中的事务 id，而唯一不同的是 delete 操作修改的的是隐藏列中删除标记的。当事务回滚时，事务中的 update 和 delete 操作将视为全部失败，回退回旧版本时会查询 undo log 中的内容，将已修改的数据行执行一个类似于 update 的操作，修改为旧版本的数据。</p>\n<p>​\tundo log 中的变更行为不仅是事务进行回滚时的数据来源，而且也是 MVCC 快照读中的数据来源。MVCC 快照读被称为是一种不加锁的读，就是因为不对数据行进行读操作（对数据行进行读操作时会上共享锁）而是对 undo log 进行读操作。而且对于 MVCC 查询快照中的内容也有一个清晰的界定，就是快照进行进行生成操作的时刻之前已经提交的事务的数据，而在与生成快照操作时其他事务提交的数据以及快照生成后其他事务提交的数据则不会被记录到此次快照中。简而言之，数据在快照生成操作在按下开始的一瞬间就已经定格。这种 MVCC 快照读机制，只存在于 RC (读已提交)、RR (可重复读) 这两个隔离级别中，而此二者的之间的差异仅仅在于在一次事务中生成快照的次数。对于 RR 隔离级别，在一次事务中只会生成一次 MVCC 查询快照；而对于 RC 隔离级别，一次事务中的每条查询语句都会生成一个 MVCC 查询快照。而如果要进行当前读操作读取数据库中的数据时，则要在 SQL 中显示添加加锁操作，不过这会对性能造成一定的影响。</p>\n<p>​\t总而言之，undo log 在保证了事务的原子性和一致性的同时，也对并发操作下对数据库的读写的性能提升有着不可忽视的贡献。不仅如此，undo log 中过于早期的版本的数据，对于正在进行的事务而言已经失去了应有的意义变成了一种冗余，此时，purge 线程会将这些相对来说冗余的数据以及数据空洞进行回收操作，进一步优化性能。</p>\n",
            "tags": []
        },
        {
            "id": "https://zhiyuan-porg.github.io/2024/09/23/%E7%B4%A2%E5%BC%95%E3%80%81%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/",
            "url": "https://zhiyuan-porg.github.io/2024/09/23/%E7%B4%A2%E5%BC%95%E3%80%81%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/",
            "title": "索引、存储引擎",
            "date_published": "2024-09-23T02:14:02.962Z",
            "content_html": "<h2 id=\"1存储引擎\"><a class=\"anchor\" href=\"#1存储引擎\">#</a> 1. 存储引擎</h2>\n<p>MySQL 的存储引擎是指数据库管理系统（DBMS）中用于存储和检索数据的具体实现方式，数据库管理系统使用存储引擎进行创建、查询、更新和删除数据。不同的存储引擎提供不同的存储机制、索引技巧、锁定水平等功能。</p>\n<p>存储引擎决定了 MySQL 底层组织数据的方式，不同的存储引擎之间大致有如下特点：</p>\n<blockquote>\n<p><strong>数据存储方式</strong>：存储引擎决定了数据的物理存储方式，影响数据的读取和写入效率。</p>\n<p><strong>事务支持</strong>：一些存储引擎支持 ACID（原子性、一致性、隔离性、持久性）事务，能够保证数据的一致性和完整性，而有些则不支持。</p>\n<p><strong>锁机制</strong>：不同的存储引擎有不同的锁定策略，影响并发操作的性能。例如，InnoDB 使用行级锁，而 MyISAM 使用表级锁。</p>\n<p><strong>索引方式</strong>：存储引擎提供不同类型的索引，影响查询性能和速度。</p>\n<p><strong>数据恢复</strong>：某些存储引擎提供数据恢复功能，能够在系统崩溃后恢复数据。</p>\n</blockquote>\n<h3 id=\"11常见的存储引擎\"><a class=\"anchor\" href=\"#11常见的存储引擎\">#</a> 1.1. 常见的存储引擎</h3>\n<p>常见的存储引擎及一些特性如下：</p>\n<table>\n<thead>\n<tr>\n<th>特点</th>\n<th>InnoDB</th>\n<th>MyISAM</th>\n<th>MEMORY</th>\n<th>MERGE</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>存储限制</td>\n<td>64TB</td>\n<td>有</td>\n<td>有</td>\n<td>没有</td>\n</tr>\n<tr>\n<td>事务安全</td>\n<td>支持</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>锁机制</td>\n<td>行锁、表锁</td>\n<td>表锁</td>\n<td>表锁</td>\n<td>表锁</td>\n</tr>\n<tr>\n<td>B 树索引</td>\n<td>支持</td>\n<td>支持</td>\n<td>支持</td>\n<td>支持</td>\n</tr>\n<tr>\n<td>哈希索引</td>\n<td></td>\n<td></td>\n<td>支持</td>\n<td></td>\n</tr>\n<tr>\n<td>全文索引</td>\n<td>支持 (5.6 版本之后)</td>\n<td>支持</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>集群索引</td>\n<td>支持</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>数据索引</td>\n<td>支持</td>\n<td></td>\n<td>支持</td>\n<td></td>\n</tr>\n<tr>\n<td>索引缓存</td>\n<td>支持</td>\n<td>支持</td>\n<td>支持</td>\n<td>支持</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"111innodb存储引擎\"><a class=\"anchor\" href=\"#111innodb存储引擎\">#</a> 1.1.1.InnoDB 存储引擎</h4>\n<p>InnoDB 是 MySQL5.5 版本后的默认存储引擎，其兼顾了高可靠性和高性能。高可靠性在于其拥有强大的事务管理功能使得在同一个事务内的操作在遇到异常、错误等问题时可以回滚，保证了数据的一致性。高性能则在于其支持 MVCC (多并发版本控制)，支持快照读（不加锁的读），而且支持行锁（操作索引列时）等操作大大提升了其性能。</p>\n<p><strong>特点：</strong></p>\n<p><strong>事务支持</strong>：支持 ACID 事务属性，可以保证事务的一致性、隔离性、持久性和原子性。</p>\n<p><strong>行级锁定</strong>：使用行级锁定机制，多个事务可以并行执行，提高了并发处理能力。</p>\n<p><strong>外键支持</strong>：支持外键约束，确保数据库中的数据完整性。</p>\n<p><strong>存储形式</strong>：.frm - 表定义文件，.ibd - 数据文件和索引文件（索引和数据是存放在一起的）。</p>\n<p><strong>MVCC（多版本并发控制）</strong>：InnoDB 实现了 MVCC 来支持读取未提交的数据，提高并发性能。</p>\n<p><strong>恢复机制</strong>：支持崩溃恢复机制，可以在数据库异常终止后自动恢复数据。</p>\n<p><strong>缓冲池</strong>：使用缓冲池来缓存表的数据和索引，减少了磁盘 I/O 操作，提高了性能。</p>\n<p><strong>自适应哈希索引</strong>：InnoDB 可以自动维护哈希索引，并根据查询的频率来创建哈希索引，提高某些查询的性能。</p>\n<p><strong>支持分区表</strong>：支持表分区，可以在大型表上实现更好的性能和管理。</p>\n<p><strong>全文索引</strong>：支持全文索引，可以在文本数据上进行快速的全文搜索。</p>\n<h4 id=\"112myisam存储引擎\"><a class=\"anchor\" href=\"#112myisam存储引擎\">#</a> 1.1.2.MyISAM 存储引擎</h4>\n<p>在 5.1 版本之前，MyISAM 存储引擎是 MySQL 的默认存储引擎，以轻巧、结构简单和占用空间少而被运用在读操作较多的场景。其中，MyISAM 引擎只支持表锁且不支持事务也没有 MVCC 等，因此虽然在非并发的的情况的下 MyISAM 是优于 InnoDB 的，但在高并发的场景下，InnoDB 的性能是远优于 MyISAM 的。</p>\n<p>** 特点： **</p>\n<p><strong>非事务型</strong>：不支持事务处理，因此不具备事务的 ACID 属性（原子性、一致性、隔离性、持久性）。</p>\n<p><strong>表级锁定</strong>：使用表级锁而不是行级锁，这意味着在写入（INSERT、UPDATE、DELETE）时会锁定整个表，影响读写并发性能。</p>\n<p><strong>读取速度快</strong>：MyISAM 表结构简单，读取速度快，尤其适合进行大量的 SELECT 查询。</p>\n<p><strong>空间和性能</strong>：MyISAM 对磁盘空间的利用率高，可以压缩数据以减少磁盘空间的占用，同时其查询性能也非常高效。</p>\n<p><strong>压缩功能</strong>：MyISAM 支持静态表（static tables），这类表可以在创建时被压缩，从而减少存储空间的需求。</p>\n<blockquote>\n<p>MySIAM 表支持三种不同存储格式：</p>\n<p><strong>静态表</strong>：静态表是默认的存储格式，静态表中的字段都是非变长的字段（char），优点是：存储非常迅速，出现故障容易恢复；缺点是：占用的空间通常比动态表多。</p>\n<p><strong>动态表</strong>：动态表的字段是变长的（varchar），优点是：占用的空间相对较少，但是频繁地更新删除记录会产生碎片，需要定期改善性能，并且出现故障的时候恢复相对比较困难。</p>\n<p><strong>压缩表</strong>：MyISAM 可以使用 myisampack 工具压缩表数据，压缩表占用磁盘空间小，每个记录是被单独压缩的，所以只有非常小的访问开支。</p>\n</blockquote>\n<p><strong>存储形式</strong>：.frm - 表定义文件，.myd - 数据文件，.myi - 索引文件（索引和数据是分开存放的）。</p>\n<p><strong>容易管理</strong>：MyISAM 的数据文件和索引文件都是独立的，使得在发生问题时可以单独对数据文件或索引文件进行修复，而不需要影响整个数据库。</p>\n<p><strong>全文索引支持</strong>：提供全文搜索功能，非常适合需要执行全文检索的应用。</p>\n<blockquote>\n<p><strong>InnoDB 与 MyISAM 对比</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\"></th>\n<th style=\"text-align:center\">InooDB</th>\n<th style=\"text-align:center\">MyISAM</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">存储文件</td>\n<td style=\"text-align:center\">.frm (表定义文件)，ibd (数据文件和索引文件)</td>\n<td style=\"text-align:center\">.frm (表定义文件)、.myi (索引文件)、.myd (数据文件)</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">锁</td>\n<td style=\"text-align:center\">表锁和行锁（在操作索引列时）</td>\n<td style=\"text-align:center\">表锁</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">事务</td>\n<td style=\"text-align:center\">支持</td>\n<td style=\"text-align:center\">不支持</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">CRUD 场景</td>\n<td style=\"text-align:center\">读、写</td>\n<td style=\"text-align:center\">读较多的场景</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">count</td>\n<td style=\"text-align:center\">遍历表</td>\n<td style=\"text-align:center\">内置的 count 计数器（无查询条件时）</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">索引结构</td>\n<td style=\"text-align:center\">B+Tree</td>\n<td style=\"text-align:center\">B+Tree</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">应用场景</td>\n<td style=\"text-align:center\">事务、并发读写</td>\n<td style=\"text-align:center\">关注于读取性能</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">外键</td>\n<td style=\"text-align:center\">支持</td>\n<td style=\"text-align:center\">不支持</td>\n</tr>\n</tbody>\n</table>\n</blockquote>\n<h4 id=\"113-merge存储引擎\"><a class=\"anchor\" href=\"#113-merge存储引擎\">#</a> 1.1.3. Merge 存储引擎</h4>\n<p>Merge 用于将一系列等同的 MyISAM 表以逻辑方式组合在一起，并作为一个对象・引用它。这些 MyISAM 表必须结构完全相同。Merge 表本身没有数据，对 Merge 类型的表进行查询、更新、删除的操作，就是对内部的 MyISAM 表进行的，Merge 表的优点在于可以突破对单个 MyISAM 表大小的限制，通过将不同的表分布在多个磁盘上，可以有效的改善 Merge 表的访问效率。</p>\n<p>Merge 数据表的定义里可以包括一个 INSERT_METHOD 选项，这个选项的可取值是 NO、FIRST、LAST，他们的含义依次是禁止插入、插入到第一个子表、插入到最后一个子表。</p>\n<h4 id=\"114-memory存储引擎\"><a class=\"anchor\" href=\"#114-memory存储引擎\">#</a> 1.1.4. Memory 存储引擎</h4>\n<p>Memory 存储引擎将表的数据存放在内存中。每个 Memory 表实际对应一个磁盘文件，格式是.frm ，该文件中只存储表的结构，而其数据文件，都是存储在内存中，这样有利于数据的快速处理，提高整个表的效率。Memory 类型的表访问非常地快，因为他的数据是存放在内存中的，并且默认使用 HASH 索引 ，但是服务一旦关闭，表中的数据就会丢失。它对表的大小有要求，不能建立太大的表。所以，这类数据库只使用在相对较小的数据库表。</p>\n<h2 id=\"2索引\"><a class=\"anchor\" href=\"#2索引\">#</a> 2. 索引</h2>\n",
            "tags": []
        },
        {
            "id": "https://zhiyuan-porg.github.io/2024/09/19/%E6%97%A5%E5%BF%97%E5%8F%8A%E9%9B%86%E7%BE%A4/",
            "url": "https://zhiyuan-porg.github.io/2024/09/19/%E6%97%A5%E5%BF%97%E5%8F%8A%E9%9B%86%E7%BE%A4/",
            "title": "日志、分表及集群",
            "date_published": "2024-09-19T10:27:45.583Z",
            "content_html": "<h2 id=\"1mysql日志\"><a class=\"anchor\" href=\"#1mysql日志\">#</a> 1.MySQL 日志</h2>\n<h3 id=\"11二进制日志\"><a class=\"anchor\" href=\"#11二进制日志\">#</a> 1.1. 二进制日志</h3>\n<p>​\t在 MySQL 中，二进制日志可以记录数据库的变更操作，比如增加、删除、修改等操作，但并不会记录查询相关的操作（select、show、explain、desc 等）。借助这一特性，二进制日志可以用于数据恢复、主从复制等操作中。其中，二进制数据又分为 SBR、RBR、MBR 三种类型。</p>\n<p>**SBR: ** 记录对数据库数据进行变更的操作的原生的 SQL 语句</p>\n<blockquote>\n<p><strong>优点：</strong>  当一个 SQL 语句修改多行数据时，只需要记录一条 SQL 语句，binlog 的所需占用的存储容量比较小，节约 IO，提升日志记录性能</p>\n<p>** 缺点： ** 当原生的 SQL 语句中含有诸如 now ()、uuid 等不确定的数据时会导致数据不一致的问题，也就是再次执行这条 SQL 语句，并不能复现 now ()、uuid 等不确定值。</p>\n</blockquote>\n<p><strong>RBR:</strong> 记录数据变更前和变更后的对比</p>\n<blockquote>\n<p><strong>优点：</strong>  如果 SQL 语句中含有诸如 now ()、uuid 等这类不确定的数值时，日志中记录的是执行该 SQL 后所生成的确定的值，保证了数据的一致性</p>\n<p>** 缺点： ** 当一个 SQL 语句修改多行数据时，日志会详细地记录每一行的修改，binlog 日志暴涨</p>\n</blockquote>\n<p><strong>MBR：</strong> 综合了 SBR 和 RBR 的优点，在一般情况下用 SBR 记录日志，当 SQL 语句中含有 now ()、uuid 等不确定的数据时采用 RBR 记录日志。这种方式既减少了日志量，又可以保证数据的一致性。</p>\n<h3 id=\"12查询日志\"><a class=\"anchor\" href=\"#12查询日志\">#</a> 1.2. 查询日志</h3>\n<p>​\t在 MySQL 中还存在查询日志，与二进制日志只记录对数据库的变更操作不同，它记录了 MySQL 接收到的所有 SQL 命令，即包括增删改查，又包括客户端连接及断等详细信息。</p>\n<h3 id=\"13慢查询日志\"><a class=\"anchor\" href=\"#13慢查询日志\">#</a> 1.3. 慢查询日志</h3>\n<p>​\t在 MySQL 中存在一个系统变量 <strong>long_query_time（默认是 10 秒）</strong>，当执行的 SQL 语句超过这个阈值时，就会被定义为慢查询语句，然后存入慢查询日志中。慢查询日志的所存在的意义，就是收集那些执行时间相对较长的 SQL 语句，便于单独优化以提升系统性能。</p>\n<h2 id=\"2表拆分\"><a class=\"anchor\" href=\"#2表拆分\">#</a> 2. 表拆分</h2>\n<p>​\t对于千万级数据量的数据库，应用常规的优化手段过后，仍然存在性能瓶颈。此时我可以采用分表的方式，减少一次查询的数据量以提升性能。对于表的拆分方式，又有<strong>水平分表</strong>和<strong>垂直分表</strong>两种，且各有利弊。</p>\n<p><strong>水平分表：</strong>  是对数据行的拆分，按照某种规则（比如 % 操作）将一个大表拆分成若干的小表。这种方式看起来更像是一种数据归档分类操作，比如将一些数据按照年份、月份、地区等划分。但其弊端就是在业务层的逻辑处理较为繁琐，需要参照拟定的分表规则以正确无误得操作指定的数据表。</p>\n<blockquote>\n<p><strong>注：</strong> 水平分表的操作看起来和数据分区十分相似，其实两之间还是有比较大的区别的。</p>\n<p><strong>数据分区</strong>（也称为表分区）是将表中的数据逻辑上划分为多个部分，每个部分称为一个分区，而物理上这些分区可能存储在不同的磁盘或服务器上。分区可以是基于范围、列表、哈希或复合方法。数据分区的优点包括提高查询效率、简化数据维护、更好的空间管理和并发控制。然而，分区也增加了复杂性，可能导致性能下降，并且不适用于所有场景。</p>\n<p><strong>区别</strong>：</p>\n<ol>\n<li><strong>目标</strong>：水平分表通常是为了解决单表数据量过大的问题，而数据分区则是为了提高查询性能和管理大型表。</li>\n<li><strong>方法</strong>：水平分表是通过创建多个结构相同的表来实现，数据分区是在单个表内部创建多个分区。</li>\n<li><strong>透明性</strong>：分区对于应用程序来说是透明的，而分表可能需要应用程序知道数据分布的逻辑。</li>\n<li><strong>数据关联性</strong>：分区表内的数据保持完整的关联性，可以进行全表扫描和 JOIN 操作；分表后跨表 JOIN 操作复杂。</li>\n</ol>\n<p><strong>优点</strong>：</p>\n<ul>\n<li><strong>水平分表</strong>：提高查询性能，简化数据管理，支持分布式处理。</li>\n<li><strong>数据分区</strong>：提高查询效率，简化数据维护，更好的空间管理，提高并发性能。</li>\n</ul>\n<p><strong>缺点</strong>：</p>\n<ul>\n<li><strong>水平分表</strong>：连接操作复杂，数据一致性难以保证，分布式事务问题。</li>\n<li><strong>数据分区</strong>：增加复杂性，性能下降风险，不适用于所有场景，分区键选择关键。</li>\n</ul>\n</blockquote>\n<p><strong>垂直分表：</strong> 对于数据量不大，但字段很多的数据表，其中也包含了一些访问频率不高的字段，但在检索时却还要检索这些冗余的数据，大大降低的 IO 的性能。此时，我们可以将表按照字段进拆分，以提高的其效率。但当要查询到⼀些主表上没有的列，必须使⽤关联查询来检索数据，提⾼了复杂性并且降低了⼀定的性能</p>\n<blockquote>\n<p><strong>注：</strong> 拆分后的表之间是一对一的关系</p>\n</blockquote>\n<p>垂直分表的相关规则：</p>\n<p>​\t把不常⽤的字段单独放在⼀张表</p>\n<p>​\t较⼤的列单独拆分出来</p>\n<p>​\t经常组合查询的列放在⼀张表中</p>\n<p>​\t所有拆分的表都建⽴外键与主表关联</p>\n<p>##3.MySQL 集群</p>\n<h3 id=\"31-读写分离架构\"><a class=\"anchor\" href=\"#31-读写分离架构\">#</a> 3.1 . 读写分离架构</h3>\n<p>​\tMySQL 读写分离架构是一种常见的数据库架构，用于提高数据库的读取性能和吞吐量。在这种架构中，通常有一个主数据库（Master）负责处理写操作（如 INSERT、UPDATE、DELETE），以及一个或多个从数据库（Slaves）负责处理读操作（如 SELECT）。这种架构的目的是将读写负载分散到多个服务器，以此来提高性能和可用性。</p>\n<p><strong>实现读写分离的方式主要有以下几种：</strong></p>\n<ol>\n<li>\n<p><strong>应用程序层实现</strong>：在应用程序代码中，根据执行的操作类型（读或写），手动指定使用主数据库还是从数据库。这种方式简单易实现，但当架构调整时，可能需要修改代码，且难以实现高级功能，如自动分库、分表等。</p>\n</li>\n<li>\n<p><strong>中间件实现</strong>：使用数据库代理中间件，如 MySQL Proxy、Atlas、MyCat 等，来自动进行读写分离。中间件位于应用程序和数据库服务器之间，根据配置的规则将请求路由到合适的数据库服务器。这种方式的优点是架构设计更灵活，可以实现更高级的控制，如透明化水平拆分、故障转移、监控等，且对业务代码的影响小。</p>\n</li>\n<li>\n<p><strong>MySQL Connector/J</strong>：使用 MySQL 的 JDBC 驱动程序实现读写分离。在配置 JDBC 连接字符串时，指定主库和从库的地址，驱动程序会根据查询类型自动将请求路由到正确的数据库服务器。</p>\n</li>\n<li>\n<p><strong>Sharding-JDBC</strong>：使用 ShardingSphere 提供的 Sharding-JDBC 实现读写分离。Sharding-JDBC 是一个客户端的分片中间件，它提供了读写分离和分库分表的功能。</p>\n</li>\n</ol>\n<p><strong>读写分离的优点包括：</strong></p>\n<ul>\n<li>提高读取性能：通过将读取负载分散到多个从服务器，可以显著提高查询性能。</li>\n<li>降低主服务器的压力：写操作集中在主服务器上，读操作分散到从服务器，减轻了主服务器的负担。</li>\n<li>提高数据可用性：即使主服务器发生故障，从服务器仍然可以提供读取服务。</li>\n</ul>\n<p><strong>读写分离的缺点包括：</strong></p>\n<ul>\n<li>数据延迟：从服务器的数据可能会因为复制延迟而不实时。</li>\n<li>复杂性增加：需要管理多个数据库服务器和处理数据同步的问题。</li>\n<li>事务处理复杂：跨服务器的事务处理会变得复杂。</li>\n</ul>\n<p>在实施读写分离时，还需要考虑数据同步的方式，如基于二进制日志的异步复制或基于 GTID 的同步复制，以及如何确保数据的一致性和系统的高可用性。</p>\n<h3 id=\"32mysql主从复制\"><a class=\"anchor\" href=\"#32mysql主从复制\">#</a> 3.2.MySQL 主从复制</h3>\n<p><strong>MySQL 主从复制的原理：</strong></p>\n<p>​\tmaster 将数据改变记录到⼆进制⽇志 (binary log) 中</p>\n<p>​\tslave 将 master 的 binary log events 拷⻉到它的中继⽇志 (relay log)</p>\n<p>​\tslave 读取中继⽇志中的数据实现数据的恢复</p>\n<p><strong>MySQL 主从复制的条件：</strong></p>\n<p>​\t Master 与 Slave 的数据库版本必须⼀致</p>\n<p>​\tMaster 与 Slave 在开始建⽴主从复制时的数据必须⼀致</p>\n<p>​\tMaster 必须开启⼆进制⽇志，Master 与 Slave 的 server_id 必须都唯⼀</p>\n<p>​\tMaster 与 Slave 的 server-uuid（在 /var/lib/mysql/auto.cnf  ⽂件中保存）不能相同</p>\n",
            "tags": []
        },
        {
            "id": "https://zhiyuan-porg.github.io/2024/07/23/JSP-MVC/",
            "url": "https://zhiyuan-porg.github.io/2024/07/23/JSP-MVC/",
            "title": "JSP-MVC",
            "date_published": "2024-07-23T02:01:03.249Z",
            "content_html": "<h2 id=\"jsp-mvc\"><a class=\"anchor\" href=\"#jsp-mvc\">#</a> JSP-MVC</h2>\n<h2 id=\"1jsp\"><a class=\"anchor\" href=\"#1jsp\">#</a> 1.JSP</h2>\n<h3 id=\"11html和servelet的弊端\"><a class=\"anchor\" href=\"#11html和servelet的弊端\">#</a> 1.1.HTML 和 Servelet 的弊端</h3>\n<p>​\t<strong>HTML：</strong></p>\n<p>​\t优点：方便页面的布局及美化</p>\n<p>​\t缺点：不能制作动态内容</p>\n<p>​\t<strong>Servlet：</strong></p>\n<p>​\t优点：可以制作动态内容</p>\n<pre><code>缺点：不方便写CSS和JS代码\n</code></pre>\n<blockquote>\n<p>二者的优缺点刚好互补，两者综合起来就刚刚好是 JSP 的设计思想</p>\n</blockquote>\n<h3 id=\"12jsp简介\"><a class=\"anchor\" href=\"#12jsp简介\">#</a> 1.2.JSP 简介</h3>\n<p>​\t以 Java 作为脚本语言，部署在网络服务器上，可以根据客户端的请求内容动态生成 HTML、XML 或其他格式文档的 Web 网页，然后返回给请求者。另外，JSP 的标签库 JSTL 提供了类似于 Java 中的 if、switch、for 等功能，开发者可以更方便地实现条件渲染和列表渲染等操作，而且也不受跨平台的限制。</p>\n<blockquote>\n<p>**Tips：**JSP 编译器可以将 JSP 文件编译成用 Java 代码写的 Servlet，然后 Servlet 再编译生成字节码文件。JSP 本质上就是一个 Servlet，属于动态技术。</p>\n</blockquote>\n<h3 id=\"13jsp语法\"><a class=\"anchor\" href=\"#13jsp语法\">#</a> 1.3.JSP 语法</h3>\n<h4 id=\"131输出脚本\"><a class=\"anchor\" href=\"#131输出脚本\">#</a> 1.3.1. 输出脚本</h4>\n<p>​\t<strong>作用：</strong> 直接输出变量值或对表达式进行计算</p>\n<pre><code class=\"language-jsp\">&lt;%= 变量名称或表达式%&gt;  // 相当于Servlet的out.print()\n</code></pre>\n<h4 id=\"132声明\"><a class=\"anchor\" href=\"#132声明\">#</a> 1.3.2. 声明</h4>\n<pre><code>**作用：** 声明全局变量或方法\n</code></pre>\n<pre><code class=\"language-jsp\">&lt;%! 全局变量或方法 %&gt;\n</code></pre>\n<h4 id=\"133插入代码片段\"><a class=\"anchor\" href=\"#133插入代码片段\">#</a> 1.3.3. 插入代码片段</h4>\n<pre><code>**作用：** 插入Java代码\n</code></pre>\n<pre><code class=\"language-jsp\">&lt;% Java代码 %&gt; \n</code></pre>\n<h3 id=\"14jsp九大内置对象\"><a class=\"anchor\" href=\"#14jsp九大内置对象\">#</a> 1.4.JSP 九大内置对象</h3>\n<p>​\t<strong>PageContext:</strong> 页面域</p>\n<p>​\t<strong>Request：</strong> HttpServletRequest (请求域)</p>\n<p>​\t<strong>Session：</strong> 会话域</p>\n<p>​\t<strong>Application：</strong> 上下文域</p>\n<blockquote>\n<p>以上为四大域对象， 从大到小依次为 Application &gt; Session &gt; Request &gt; PageContext</p>\n<p><strong>相关的方法：</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">作用域</th>\n<th style=\"text-align:center\">Java 代码</th>\n<th style=\"text-align:center\">EL 的写法</th>\n<th style=\"text-align:center\">范围大小</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">页面域</td>\n<td style=\"text-align:center\">&lt;% = pageContext.getAttribute (&quot;键名&quot;) %&gt;</td>\n<td style=\"text-align:center\" pageScope.键名=\"\">$</td>\n<td style=\"text-align:center\">1</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">请求域</td>\n<td style=\"text-align:center\">&lt;% = request.getAttribute (&quot;键名&quot;) %&gt;</td>\n<td style=\"text-align:center\" requestScope.键名=\"\">$</td>\n<td style=\"text-align:center\">2</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">会话域</td>\n<td style=\"text-align:center\">&lt;% = session.getAttribute (&quot;键名&quot;) %&gt;</td>\n<td style=\"text-align:center\" sessionScope.键名=\"\">$</td>\n<td style=\"text-align:center\">3</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">上下文域</td>\n<td style=\"text-align:center\">&lt;% = application.getAttribute (&quot;键名&quot;) %&gt;</td>\n<td style=\"text-align:center\" applicationScope.键名=\"\">$</td>\n<td style=\"text-align:center\">4</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">自动查找</td>\n<td style=\"text-align:center\">&lt;% = pageContext.findAttribute (&quot;键名&quot;) %&gt;</td>\n<td style=\"text-align:center\"></td>\n<td style=\"text-align:center\"></td>\n</tr>\n</tbody>\n</table>\n</blockquote>\n<p>​\t<strong>Response：</strong> HttpServletResponse</p>\n<p>​\t<strong>Out</strong></p>\n<p>​\t<strong>Config：</strong> ServletConfig</p>\n<p>​\t<strong>Page:</strong> 当前页面的引用，就是 this</p>\n<p>​\t<strong>Exception：</strong> 封装了出现的异常， 只有在错误页面的中才会存在</p>\n<h4 id=\"141pagecontext域\"><a class=\"anchor\" href=\"#141pagecontext域\">#</a> 1.4.1PageContext 域</h4>\n<p>​\tPageContext 域是 servlet 中 4 个域对象中最后一个了，而且大小也是<strong>最小的</strong>，只在当前页面下生效，且在不同的页面下不能实现页面共享（即使是一次请求）</p>\n<p>​\t有关的方法：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">方法</th>\n<th style=\"text-align:center\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">void setAttribute(String key, Object value)</td>\n<td style=\"text-align:center\">向页面域中添加键和值</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Object getAttribute(String key)</td>\n<td style=\"text-align:center\">从页面域中得到值</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">void removeAttribute(String key)</td>\n<td style=\"text-align:center\">删除页面域中键值对</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Object findAttribute(String key)</td>\n<td style=\"text-align:center\">自动从四个作用域中去查某个键，从小到大的范围来查找，如果找到就停止。如果没有找到，返回 null，<strong>该方法是页面域独有的</strong></td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"142exception对象\"><a class=\"anchor\" href=\"#142exception对象\">#</a> 1.4.2Exception 对象</h4>\n<p>​\t<strong>Exception 属于 JSP 的九大内置对象，但是只有错误页面才会生成该对象，普通的 JSP 页面不会存在 Exception 对象</strong></p>\n<blockquote>\n<p>​\t<strong>warning：</strong></p>\n<p>​\t(1) 当前页面只有设置了 <strong>isErrorPage = true</strong> 时才可以使用 exception 内置对象</p>\n<p>​\t(2) 常规页面只有八大内置对象，只有错误页面才有九大内置对象</p>\n</blockquote>\n<h2 id=\"2el表达式\"><a class=\"anchor\" href=\"#2el表达式\">#</a> 2.EL 表达式</h2>\n<p>​\t<strong>语法</strong></p>\n<pre><code class=\"language-jsp\">$&#123; 变量名或表达式&#125;\n</code></pre>\n<h3 id=\"21食用说明\"><a class=\"anchor\" href=\"#21食用说明\">#</a> 2.1. 食用说明</h3>\n<p>​\t<strong>变量名：</strong> 变量名即可以是诸如 x, y, z 这样的普通变量，也可以是 Object、List、Map、数组或者 JavaBean 等</p>\n<blockquote map[xiaoshabi]=\"\">\n<p>Tips: 键名中如果有特殊字符时，可以使用双引号或者单引号将其引起来。 e.g. $</p>\n</blockquote>\n<p>​\t<strong>表达式：</strong> EL 表达式中的表达式可以包含常规的算术表达式（ + 、 - 、* 、/ 、%）、比较表达式（ == 、 != 、&lt;、&lt;=、&gt; 、&gt;=）、逻辑表达式（&amp;&amp; 、|| 、！）、三元运算以及判空表达式（${ empty 变量名}）</p>\n<h2 id=\"3jstl标签库\"><a class=\"anchor\" href=\"#3jstl标签库\">#</a> 3.JSTL 标签库</h2>\n<p>​\t使用时先导入 jar 包</p>\n<h3 id=\"31相关标签\"><a class=\"anchor\" href=\"#31相关标签\">#</a> 3.1 相关标签</h3>\n<p>**&lt;c:if test=&quot;条件判断表达式&quot;&gt; ** 条件判断</p>\n<p><strong>&lt;c:choose&gt;</strong> 多分支判断</p>\n<blockquote>\n<p><strong>类似于 switch，层级结构为：</strong></p>\n<pre><code class=\"language-jsp\">&lt;c:choose&gt;\n    &lt;c:when test = &quot;条件表达式&quot;&gt;\n   \t \txxxxxxxx\n    &lt;/c:when&gt;\n    //默认条件，相当于default\n    &lt;c:otherwise&gt;\n        xxxxxxx\n    &lt;/c:otherwise&gt;\n&lt;/c:choose\n</code></pre>\n</blockquote>\n<p><strong>&lt;c:forEach&gt;</strong> 循环渲染</p>\n<blockquote>\n<p><strong>类似于 for 语句，相关的参数有</strong></p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">属性名</th>\n<th style=\"text-align:center\">EL 支持</th>\n<th style=\"text-align:center\">类型</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">items</td>\n<td style=\"text-align:center\">true</td>\n<td style=\"text-align:center\">数组或集合</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">var</td>\n<td style=\"text-align:center\">false</td>\n<td style=\"text-align:center\">String</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">varStatus</td>\n<td style=\"text-align:center\">false</td>\n<td style=\"text-align:center\">String</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">begin</td>\n<td style=\"text-align:center\">true</td>\n<td style=\"text-align:center\">int</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">end</td>\n<td style=\"text-align:center\">true</td>\n<td style=\"text-align:center\">int</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">step</td>\n<td style=\"text-align:center\">true</td>\n<td style=\"text-align:center\">int</td>\n</tr>\n</tbody>\n</table>\n<p>其中<strong> varStatus</strong> 还有一些子属性（虽然也不是很常用）</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">属性</th>\n<th style=\"text-align:center\">数据类型</th>\n<th style=\"text-align:center\">含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">index</td>\n<td style=\"text-align:center\">int</td>\n<td style=\"text-align:center\">当前元素的索引号，从 0 开始</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">count</td>\n<td style=\"text-align:center\">int</td>\n<td style=\"text-align:center\">遍历到当前位置，一共遍历了多少个元素（默认从 1 开始）</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">first</td>\n<td style=\"text-align:center\">boolean</td>\n<td style=\"text-align:center\">如果当前遍历的是第 1 个元素，则返回 true</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">last</td>\n<td style=\"text-align:center\">boolean</td>\n<td style=\"text-align:center\">如果当前遍历的是最后 1 个元素，则返回 true</td>\n</tr>\n</tbody>\n</table>\n</blockquote>\n<h2 id=\"4三层架构-and-mvc\"><a class=\"anchor\" href=\"#4三层架构-and-mvc\">#</a> 4. 三层架构 And MVC</h2>\n<h3 id=\"41三层架构\"><a class=\"anchor\" href=\"#41三层架构\">#</a> 4.1. 三层架构</h3>\n<p>三层架构（Three-Tier Architecture）和 MVC（Model-View-Controller）是两种常见的软件设计模式，它们用于构建可维护、可扩展和模块化的应用程序。</p>\n<p>三层架构是一种分层的客户端 - 服务器架构，它将应用程序分为三个逻辑层次：</p>\n<ol>\n<li>\n<p><strong>表示层（Presentation Layer）</strong>：这一层处理用户界面和用户交互。它负责接收用户的输入，调用业务逻辑层来处理数据，并显示信息给用户。</p>\n</li>\n<li>\n<p><strong>业务逻辑层（Business Logic Layer）</strong>：也称为中间层或服务层，它包含应用程序的业务规则和逻辑。这一层处理数据的加工和计算，如数据库操作、数值计算等。</p>\n</li>\n<li>\n<p><strong>数据访问层（Data Access Layer）</strong>：这一层负责数据持久化，包括数据的读取、写入和更新。它通常与数据库交互，执行 CRUD（创建、读取、更新、删除）操作。</p>\n</li>\n</ol>\n<p>三层架构的优点包括：</p>\n<ul>\n<li><strong>分离关注点</strong>：每一层都有其特定的职责，这有助于分离关注点，使得开发和维护更加容易。</li>\n<li><strong>可维护性</strong>：每一层可以独立开发和测试，提高了代码的可维护性。</li>\n<li><strong>可扩展性</strong>：可以根据需要扩展任何一层，而不会影响到其他层。</li>\n</ul>\n<h3 id=\"42mvc\"><a class=\"anchor\" href=\"#42mvc\">#</a> 4.2.MVC</h3>\n<p>MVC 是一种设计模式，用于实现用户界面的分离。它将应用程序分为三个主要组件：</p>\n<ol>\n<li>\n<p><strong>模型（Model）</strong>：代表应用程序的数据和业务逻辑。模型负责处理数据和业务规则。</p>\n</li>\n<li>\n<p><strong>视图（View）</strong>：代表用户界面。视图负责显示数据（模型）和接收用户输入。</p>\n</li>\n<li>\n<p><strong>控制器（Controller）</strong>：作为模型和视图之间的中介。控制器接收用户的输入，调用模型处理数据，然后选择合适的视图显示结果。</p>\n</li>\n</ol>\n<p>MVC 的优点包括：</p>\n<ul>\n<li><strong>分离关注点</strong>：MVC 通过将数据（模型）、用户界面（视图）和业务逻辑（控制器）分离，使得开发和维护更加清晰。</li>\n<li><strong>可维护性</strong>：由于关注点的分离，MVC 使得代码更加模块化，易于维护和测试。</li>\n<li><strong>可重用性</strong>：模型和视图可以独立于控制器重用，提高了代码的重用性。</li>\n</ul>\n<h3 id=\"43三层架构与mvc的关系\"><a class=\"anchor\" href=\"#43三层架构与mvc的关系\">#</a> 4.3. 三层架构与 MVC 的关系</h3>\n<p>三层架构和 MVC 可以结合使用。在这种结合中：</p>\n<ul>\n<li><strong>表示层</strong>通常包含 MVC 的视图和控制器。视图负责显示数据，控制器处理用户输入和调用业务逻辑层。</li>\n<li><strong>业务逻辑层</strong>对应于 MVC 的模型，处理应用程序的核心逻辑。</li>\n<li><strong>数据访问层</strong>通常不直接包含在 MVC 中，但它为模型提供数据持久化的支持。</li>\n</ul>\n<p>通过将三层架构与 MVC 结合，可以构建一个结构清晰、易于维护和扩展的应用程序。</p>\n",
            "tags": []
        }
    ]
}