<?xml version="1.0"?>
<rss version="2.0">
    <channel>
        <title>只想摆烂，阿巴阿巴阿巴</title>
        <subtitle></subtitle>
        <icon>https://zhiyuan-porg.github.io/assets/favicon.ico</icon>
        <link>https://zhiyuan-porg.github.io</link>
        <author>
          <name>SanYue</name>
        </author>
        <description></description>
        <language>zh-cn</language>
        <pubDate>Thu, 19 Sep 2024 18:27:45 +0800</pubDate>
        <lastBuildDate>Thu, 19 Sep 2024 18:27:45 +0800</lastBuildDate>
        <item>
            <guid isPermalink="true">https://zhiyuan-porg.github.io/2024/09/19/MySQL%E5%91%BD%E4%BB%A4%E3%80%81%E6%97%A5%E5%BF%97%E5%8F%8A%E9%9B%86%E7%BE%A4/</guid>
            <title>日志、分表及集群</title>
            <link>https://zhiyuan-porg.github.io/2024/09/19/MySQL%E5%91%BD%E4%BB%A4%E3%80%81%E6%97%A5%E5%BF%97%E5%8F%8A%E9%9B%86%E7%BE%A4/</link>
            <pubDate>Thu, 19 Sep 2024 18:27:45 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;1mysql日志&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#1mysql日志&#34;&gt;#&lt;/a&gt; 1.MySQL 日志&lt;/h2&gt;
&lt;h3 id=&#34;11二进制日志&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#11二进制日志&#34;&gt;#&lt;/a&gt; 1.1. 二进制日志&lt;/h3&gt;
&lt;p&gt;​	在 MySQL 中，二进制日志可以记录数据库的变更操作，比如增加、删除、修改等操作，但并不会记录查询相关的操作（select、show、explain、desc 等）。借助这一特性，二进制日志可以用于数据恢复、主从复制等操作中。其中，二进制数据又分为 SBR、RBR、MBR 三种类型。&lt;/p&gt;
&lt;p&gt;**SBR: ** 记录对数据库数据进行变更的操作的原生的 SQL 语句&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;** 优点：** 当一个 SQL 语句修改多行数据时，只需要记录一条 SQL 语句，binlog 的所需占用的存储容量比较小，节约 IO，提升日志记录性能&lt;/p&gt;
&lt;p&gt;** 缺点： ** 当原生的 SQL 语句中含有诸如 now ()、uuid 等不确定的数据时会导致数据不一致的问题，也就是再次执行这条 SQL 语句，并不能复现 now ()、uuid 等不确定值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;RBR:&lt;/strong&gt; 记录数据变更前和变更后的对比&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt; 如果 SQL 语句中含有诸如 now ()、uuid 等这类不确定的数值时，日志中记录的是执行该 SQL 后所生成的确定的值，保证了数据的一致性&lt;/p&gt;
&lt;p&gt;** 缺点： ** 当一个 SQL 语句修改多行数据时，日志会详细地记录每一行的修改，binlog 日志暴涨&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;MBR：&lt;/strong&gt; 综合了 SBR 和 RBR 的优点，在一般情况下用 SBR 记录日志，当 SQL 语句中含有 now ()、uuid 等不确定的数据时采用 RBR 记录日志。这种方式既减少了日志量，又可以保证数据的一致性。&lt;/p&gt;
&lt;h3 id=&#34;12查询日志&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#12查询日志&#34;&gt;#&lt;/a&gt; 1.2. 查询日志&lt;/h3&gt;
&lt;p&gt;​	在 MySQL 中还存在查询日志，与二进制日志只记录对数据库的变更操作不同，它记录了 MySQL 接收到的所有 SQL 命令，即包括增删改查，又包括客户端连接及断等详细信息。&lt;/p&gt;
&lt;h3 id=&#34;13慢查询日志&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#13慢查询日志&#34;&gt;#&lt;/a&gt; 1.3. 慢查询日志&lt;/h3&gt;
&lt;p&gt;​	在 MySQL 中存在一个系统变量 &lt;strong&gt;long_query_time（默认是 10 秒）&lt;/strong&gt;，当执行的 SQL 语句超过这个阈值时，就会被定义为慢查询语句，然后存入慢查询日志中。慢查询日志的所存在的意义，就是收集那些执行时间相对较长的 SQL 语句，便于单独优化以提升系统性能。&lt;/p&gt;
&lt;h2 id=&#34;2表拆分&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#2表拆分&#34;&gt;#&lt;/a&gt; 2. 表拆分&lt;/h2&gt;
&lt;p&gt;​	对于千万级数据量的数据库，应用常规的优化手段过后，仍然存在性能瓶颈。此时我可以采用分表的方式，减少一次查询的数据量以提升性能。对于表的拆分方式，又有&lt;strong&gt;水平分表&lt;/strong&gt;和&lt;strong&gt;垂直分表&lt;/strong&gt;两种，且各有利弊。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;水平分表：&lt;/strong&gt;  是对数据行的拆分，按照某种规则（比如 % 操作）将一个大表拆分成若干的小表。这种方式看起来更像是一种数据归档分类操作，比如将一些数据按照年份、月份、地区等划分。但其弊端就是在业务层的逻辑处理较为繁琐，需要参照拟定的分表规则以正确无误得操作指定的数据表。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;** 注：** 水平分表的操作看起来和数据分区十分相似，其实两之间还是有比较大的区别的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据分区&lt;/strong&gt;（也称为表分区）是将表中的数据逻辑上划分为多个部分，每个部分称为一个分区，而物理上这些分区可能存储在不同的磁盘或服务器上。分区可以是基于范围、列表、哈希或复合方法。数据分区的优点包括提高查询效率、简化数据维护、更好的空间管理和并发控制。然而，分区也增加了复杂性，可能导致性能下降，并且不适用于所有场景。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;区别&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;目标&lt;/strong&gt;：水平分表通常是为了解决单表数据量过大的问题，而数据分区则是为了提高查询性能和管理大型表。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;方法&lt;/strong&gt;：水平分表是通过创建多个结构相同的表来实现，数据分区是在单个表内部创建多个分区。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;透明性&lt;/strong&gt;：分区对于应用程序来说是透明的，而分表可能需要应用程序知道数据分布的逻辑。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据关联性&lt;/strong&gt;：分区表内的数据保持完整的关联性，可以进行全表扫描和 JOIN 操作；分表后跨表 JOIN 操作复杂。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;水平分表&lt;/strong&gt;：提高查询性能，简化数据管理，支持分布式处理。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据分区&lt;/strong&gt;：提高查询效率，简化数据维护，更好的空间管理，提高并发性能。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;水平分表&lt;/strong&gt;：连接操作复杂，数据一致性难以保证，分布式事务问题。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据分区&lt;/strong&gt;：增加复杂性，性能下降风险，不适用于所有场景，分区键选择关键。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;垂直分表：&lt;/strong&gt; 对于数据量不大，但字段很多的数据表，其中也包含了一些访问频率不高的字段，但在检索时却还要检索这些冗余的数据，大大降低的 IO 的性能。此时，我们可以将表按照字段进拆分，以提高的其效率。但当要查询到⼀些主表上没有的列，必须使⽤关联查询来检索数据，提⾼了复杂性并且降低了⼀定的性能&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注：&lt;/strong&gt; 拆分后的表之间是一对一的关系&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;垂直分表的相关规则：&lt;/p&gt;
&lt;p&gt;​	把不常⽤的字段单独放在⼀张表&lt;/p&gt;
&lt;p&gt;​	较⼤的列单独拆分出来&lt;/p&gt;
&lt;p&gt;​	经常组合查询的列放在⼀张表中&lt;/p&gt;
&lt;p&gt;​	所有拆分的表都建⽴外键与主表关联&lt;/p&gt;
&lt;p&gt;##3.MySQL 集群&lt;/p&gt;
&lt;h3 id=&#34;31-读写分离架构&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#31-读写分离架构&#34;&gt;#&lt;/a&gt; 3.1 . 读写分离架构&lt;/h3&gt;
&lt;p&gt;​	MySQL 读写分离架构是一种常见的数据库架构，用于提高数据库的读取性能和吞吐量。在这种架构中，通常有一个主数据库（Master）负责处理写操作（如 INSERT、UPDATE、DELETE），以及一个或多个从数据库（Slaves）负责处理读操作（如 SELECT）。这种架构的目的是将读写负载分散到多个服务器，以此来提高性能和可用性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现读写分离的方式主要有以下几种：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;应用程序层实现&lt;/strong&gt;：在应用程序代码中，根据执行的操作类型（读或写），手动指定使用主数据库还是从数据库。这种方式简单易实现，但当架构调整时，可能需要修改代码，且难以实现高级功能，如自动分库、分表等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;中间件实现&lt;/strong&gt;：使用数据库代理中间件，如 MySQL Proxy、Atlas、MyCat 等，来自动进行读写分离。中间件位于应用程序和数据库服务器之间，根据配置的规则将请求路由到合适的数据库服务器。这种方式的优点是架构设计更灵活，可以实现更高级的控制，如透明化水平拆分、故障转移、监控等，且对业务代码的影响小。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;MySQL Connector/J&lt;/strong&gt;：使用 MySQL 的 JDBC 驱动程序实现读写分离。在配置 JDBC 连接字符串时，指定主库和从库的地址，驱动程序会根据查询类型自动将请求路由到正确的数据库服务器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Sharding-JDBC&lt;/strong&gt;：使用 ShardingSphere 提供的 Sharding-JDBC 实现读写分离。Sharding-JDBC 是一个客户端的分片中间件，它提供了读写分离和分库分表的功能。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;读写分离的优点包括：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;提高读取性能：通过将读取负载分散到多个从服务器，可以显著提高查询性能。&lt;/li&gt;
&lt;li&gt;降低主服务器的压力：写操作集中在主服务器上，读操作分散到从服务器，减轻了主服务器的负担。&lt;/li&gt;
&lt;li&gt;提高数据可用性：即使主服务器发生故障，从服务器仍然可以提供读取服务。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;读写分离的缺点包括：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据延迟：从服务器的数据可能会因为复制延迟而不实时。&lt;/li&gt;
&lt;li&gt;复杂性增加：需要管理多个数据库服务器和处理数据同步的问题。&lt;/li&gt;
&lt;li&gt;事务处理复杂：跨服务器的事务处理会变得复杂。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在实施读写分离时，还需要考虑数据同步的方式，如基于二进制日志的异步复制或基于 GTID 的同步复制，以及如何确保数据的一致性和系统的高可用性。&lt;/p&gt;
&lt;h3 id=&#34;32mysql主从复制&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#32mysql主从复制&#34;&gt;#&lt;/a&gt; 3.2.MySQL 主从复制&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;MySQL 主从复制的原理：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​	master 将数据改变记录到⼆进制⽇志 (binary log) 中&lt;/p&gt;
&lt;p&gt;​	slave 将 master 的 binary log events 拷⻉到它的中继⽇志 (relay log)&lt;/p&gt;
&lt;p&gt;​	slave 读取中继⽇志中的数据实现数据的恢复&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MySQL 主从复制的条件：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​	 Master 与 Slave 的数据库版本必须⼀致&lt;/p&gt;
&lt;p&gt;​	Master 与 Slave 在开始建⽴主从复制时的数据必须⼀致&lt;/p&gt;
&lt;p&gt;​	Master 必须开启⼆进制⽇志，Master 与 Slave 的 server_id 必须都唯⼀&lt;/p&gt;
&lt;p&gt;​	Master 与 Slave 的 server-uuid（在 /var/lib/mysql/auto.cnf  ⽂件中保存）不能相同&lt;/p&gt;
 ]]></description>
        </item>
        <item>
            <guid isPermalink="true">https://zhiyuan-porg.github.io/2024/07/23/JSP-MVC/</guid>
            <title>JSP-MVC</title>
            <link>https://zhiyuan-porg.github.io/2024/07/23/JSP-MVC/</link>
            <pubDate>Tue, 23 Jul 2024 10:01:03 +0800</pubDate>
            <description><![CDATA[ &lt;h2 id=&#34;jsp-mvc&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#jsp-mvc&#34;&gt;#&lt;/a&gt; JSP-MVC&lt;/h2&gt;
&lt;h2 id=&#34;1jsp&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#1jsp&#34;&gt;#&lt;/a&gt; 1.JSP&lt;/h2&gt;
&lt;h3 id=&#34;11html和servelet的弊端&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#11html和servelet的弊端&#34;&gt;#&lt;/a&gt; 1.1.HTML 和 Servelet 的弊端&lt;/h3&gt;
&lt;p&gt;​	&lt;strong&gt;HTML：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​	优点：方便页面的布局及美化&lt;/p&gt;
&lt;p&gt;​	缺点：不能制作动态内容&lt;/p&gt;
&lt;p&gt;​	&lt;strong&gt;Servlet：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​	优点：可以制作动态内容&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;缺点：不方便写CSS和JS代码
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;二者的优缺点刚好互补，两者综合起来就刚刚好是 JSP 的设计思想&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;12jsp简介&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#12jsp简介&#34;&gt;#&lt;/a&gt; 1.2.JSP 简介&lt;/h3&gt;
&lt;p&gt;​	以 Java 作为脚本语言，部署在网络服务器上，可以根据客户端的请求内容动态生成 HTML、XML 或其他格式文档的 Web 网页，然后返回给请求者。另外，JSP 的标签库 JSTL 提供了类似于 Java 中的 if、switch、for 等功能，开发者可以更方便地实现条件渲染和列表渲染等操作，而且也不受跨平台的限制。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;**Tips：**JSP 编译器可以将 JSP 文件编译成用 Java 代码写的 Servlet，然后 Servlet 再编译生成字节码文件。JSP 本质上就是一个 Servlet，属于动态技术。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;13jsp语法&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#13jsp语法&#34;&gt;#&lt;/a&gt; 1.3.JSP 语法&lt;/h3&gt;
&lt;h4 id=&#34;131输出脚本&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#131输出脚本&#34;&gt;#&lt;/a&gt; 1.3.1. 输出脚本&lt;/h4&gt;
&lt;p&gt;​	&lt;strong&gt;作用：&lt;/strong&gt; 直接输出变量值或对表达式进行计算&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsp&#34;&gt;&amp;lt;%= 变量名称或表达式%&amp;gt;  // 相当于Servlet的out.print()
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;132声明&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#132声明&#34;&gt;#&lt;/a&gt; 1.3.2. 声明&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;**作用：** 声明全局变量或方法
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsp&#34;&gt;&amp;lt;%! 全局变量或方法 %&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h4 id=&#34;133插入代码片段&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#133插入代码片段&#34;&gt;#&lt;/a&gt; 1.3.3. 插入代码片段&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;**作用：** 插入Java代码
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsp&#34;&gt;&amp;lt;% Java代码 %&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;14jsp九大内置对象&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#14jsp九大内置对象&#34;&gt;#&lt;/a&gt; 1.4.JSP 九大内置对象&lt;/h3&gt;
&lt;p&gt;​	&lt;strong&gt;PageContext:&lt;/strong&gt; 页面域&lt;/p&gt;
&lt;p&gt;​	&lt;strong&gt;Request：&lt;/strong&gt; HttpServletRequest (请求域)&lt;/p&gt;
&lt;p&gt;​	&lt;strong&gt;Session：&lt;/strong&gt; 会话域&lt;/p&gt;
&lt;p&gt;​	&lt;strong&gt;Application：&lt;/strong&gt; 上下文域&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;以上为四大域对象， 从大到小依次为 Application &amp;gt; Session &amp;gt; Request &amp;gt; PageContext&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;相关的方法：&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;作用域&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;Java 代码&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;EL 的写法&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;范围大小&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;页面域&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&amp;lt;% = pageContext.getAttribute (&amp;quot;键名&amp;quot;) %&amp;gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34; pageScope.键名=&#34;&#34;&gt;$&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;请求域&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&amp;lt;% = request.getAttribute (&amp;quot;键名&amp;quot;) %&amp;gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34; requestScope.键名=&#34;&#34;&gt;$&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;会话域&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&amp;lt;% = session.getAttribute (&amp;quot;键名&amp;quot;) %&amp;gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34; sessionScope.键名=&#34;&#34;&gt;$&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;上下文域&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&amp;lt;% = application.getAttribute (&amp;quot;键名&amp;quot;) %&amp;gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34; applicationScope.键名=&#34;&#34;&gt;$&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;自动查找&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&amp;lt;% = pageContext.findAttribute (&amp;quot;键名&amp;quot;) %&amp;gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/blockquote&gt;
&lt;p&gt;​	&lt;strong&gt;Response：&lt;/strong&gt; HttpServletResponse&lt;/p&gt;
&lt;p&gt;​	&lt;strong&gt;Out&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​	&lt;strong&gt;Config：&lt;/strong&gt; ServletConfig&lt;/p&gt;
&lt;p&gt;​	&lt;strong&gt;Page:&lt;/strong&gt; 当前页面的引用，就是 this&lt;/p&gt;
&lt;p&gt;​	&lt;strong&gt;Exception：&lt;/strong&gt; 封装了出现的异常， 只有在错误页面的中才会存在&lt;/p&gt;
&lt;h4 id=&#34;141pagecontext域&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#141pagecontext域&#34;&gt;#&lt;/a&gt; 1.4.1PageContext 域&lt;/h4&gt;
&lt;p&gt;​	PageContext 域是 servlet 中 4 个域对象中最后一个了，而且大小也是&lt;strong&gt;最小的&lt;/strong&gt;，只在当前页面下生效，且在不同的页面下不能实现页面共享（即使是一次请求）&lt;/p&gt;
&lt;p&gt;​	有关的方法：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;方法&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;void setAttribute(String key, Object value)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;向页面域中添加键和值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Object getAttribute(String key)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;从页面域中得到值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;void removeAttribute(String key)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;删除页面域中键值对&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Object findAttribute(String key)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;自动从四个作用域中去查某个键，从小到大的范围来查找，如果找到就停止。如果没有找到，返回 null，&lt;strong&gt;该方法是页面域独有的&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h4 id=&#34;142exception对象&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#142exception对象&#34;&gt;#&lt;/a&gt; 1.4.2Exception 对象&lt;/h4&gt;
&lt;p&gt;​	&lt;strong&gt;Exception 属于 JSP 的九大内置对象，但是只有错误页面才会生成该对象，普通的 JSP 页面不会存在 Exception 对象&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;​	&lt;strong&gt;warning：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​	(1) 当前页面只有设置了 &lt;strong&gt;isErrorPage = true&lt;/strong&gt; 时才可以使用 exception 内置对象&lt;/p&gt;
&lt;p&gt;​	(2) 常规页面只有八大内置对象，只有错误页面才有九大内置对象&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;2el表达式&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#2el表达式&#34;&gt;#&lt;/a&gt; 2.EL 表达式&lt;/h2&gt;
&lt;p&gt;​	&lt;strong&gt;语法&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsp&#34;&gt;$&amp;#123; 变量名或表达式&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&#34;21食用说明&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#21食用说明&#34;&gt;#&lt;/a&gt; 2.1. 食用说明&lt;/h3&gt;
&lt;p&gt;​	&lt;strong&gt;变量名：&lt;/strong&gt; 变量名即可以是诸如 x, y, z 这样的普通变量，也可以是 Object、List、Map、数组或者 JavaBean 等&lt;/p&gt;
&lt;blockquote map[xiaoshabi]=&#34;&#34;&gt;
&lt;p&gt;Tips: 键名中如果有特殊字符时，可以使用双引号或者单引号将其引起来。 e.g. $&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;​	&lt;strong&gt;表达式：&lt;/strong&gt; EL 表达式中的表达式可以包含常规的算术表达式（ + 、 - 、* 、/ 、%）、比较表达式（ == 、 != 、&amp;lt;、&amp;lt;=、&amp;gt; 、&amp;gt;=）、逻辑表达式（&amp;amp;&amp;amp; 、|| 、！）、三元运算以及判空表达式（${ empty 变量名}）&lt;/p&gt;
&lt;h2 id=&#34;3jstl标签库&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#3jstl标签库&#34;&gt;#&lt;/a&gt; 3.JSTL 标签库&lt;/h2&gt;
&lt;p&gt;​	使用时先导入 jar 包&lt;/p&gt;
&lt;h3 id=&#34;31相关标签&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#31相关标签&#34;&gt;#&lt;/a&gt; 3.1 相关标签&lt;/h3&gt;
&lt;p&gt;**&amp;lt;c:if test=&amp;quot;条件判断表达式&amp;quot;&amp;gt; ** 条件判断&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&amp;lt;c:choose&amp;gt;&lt;/strong&gt; 多分支判断&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;类似于 switch，层级结构为：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-jsp&#34;&gt;&amp;lt;c:choose&amp;gt;
    &amp;lt;c:when test = &amp;quot;条件表达式&amp;quot;&amp;gt;
   	 	xxxxxxxx
    &amp;lt;/c:when&amp;gt;
    //默认条件，相当于default
    &amp;lt;c:otherwise&amp;gt;
        xxxxxxx
    &amp;lt;/c:otherwise&amp;gt;
&amp;lt;/c:choose
&lt;/code&gt;&lt;/pre&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;&amp;lt;c:forEach&amp;gt;&lt;/strong&gt; 循环渲染&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;类似于 for 语句，相关的参数有&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;属性名&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;EL 支持&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;类型&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;items&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;true&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;数组或集合&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;var&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;false&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;String&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;varStatus&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;false&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;String&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;begin&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;true&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;int&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;end&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;true&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;int&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;step&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;true&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;int&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;其中&lt;strong&gt; varStatus&lt;/strong&gt; 还有一些子属性（虽然也不是很常用）&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;属性&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;数据类型&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;index&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;int&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;当前元素的索引号，从 0 开始&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;count&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;int&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;遍历到当前位置，一共遍历了多少个元素（默认从 1 开始）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;first&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;boolean&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;如果当前遍历的是第 1 个元素，则返回 true&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;last&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;boolean&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;如果当前遍历的是最后 1 个元素，则返回 true&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;4三层架构-and-mvc&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#4三层架构-and-mvc&#34;&gt;#&lt;/a&gt; 4. 三层架构 And MVC&lt;/h2&gt;
&lt;h3 id=&#34;41三层架构&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#41三层架构&#34;&gt;#&lt;/a&gt; 4.1. 三层架构&lt;/h3&gt;
&lt;p&gt;三层架构（Three-Tier Architecture）和 MVC（Model-View-Controller）是两种常见的软件设计模式，它们用于构建可维护、可扩展和模块化的应用程序。&lt;/p&gt;
&lt;p&gt;三层架构是一种分层的客户端 - 服务器架构，它将应用程序分为三个逻辑层次：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;表示层（Presentation Layer）&lt;/strong&gt;：这一层处理用户界面和用户交互。它负责接收用户的输入，调用业务逻辑层来处理数据，并显示信息给用户。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;业务逻辑层（Business Logic Layer）&lt;/strong&gt;：也称为中间层或服务层，它包含应用程序的业务规则和逻辑。这一层处理数据的加工和计算，如数据库操作、数值计算等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;数据访问层（Data Access Layer）&lt;/strong&gt;：这一层负责数据持久化，包括数据的读取、写入和更新。它通常与数据库交互，执行 CRUD（创建、读取、更新、删除）操作。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;三层架构的优点包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;分离关注点&lt;/strong&gt;：每一层都有其特定的职责，这有助于分离关注点，使得开发和维护更加容易。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可维护性&lt;/strong&gt;：每一层可以独立开发和测试，提高了代码的可维护性。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可扩展性&lt;/strong&gt;：可以根据需要扩展任何一层，而不会影响到其他层。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;42mvc&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#42mvc&#34;&gt;#&lt;/a&gt; 4.2.MVC&lt;/h3&gt;
&lt;p&gt;MVC 是一种设计模式，用于实现用户界面的分离。它将应用程序分为三个主要组件：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;模型（Model）&lt;/strong&gt;：代表应用程序的数据和业务逻辑。模型负责处理数据和业务规则。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;视图（View）&lt;/strong&gt;：代表用户界面。视图负责显示数据（模型）和接收用户输入。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;控制器（Controller）&lt;/strong&gt;：作为模型和视图之间的中介。控制器接收用户的输入，调用模型处理数据，然后选择合适的视图显示结果。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;MVC 的优点包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;分离关注点&lt;/strong&gt;：MVC 通过将数据（模型）、用户界面（视图）和业务逻辑（控制器）分离，使得开发和维护更加清晰。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可维护性&lt;/strong&gt;：由于关注点的分离，MVC 使得代码更加模块化，易于维护和测试。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;可重用性&lt;/strong&gt;：模型和视图可以独立于控制器重用，提高了代码的重用性。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;43三层架构与mvc的关系&#34;&gt;&lt;a class=&#34;anchor&#34; href=&#34;#43三层架构与mvc的关系&#34;&gt;#&lt;/a&gt; 4.3. 三层架构与 MVC 的关系&lt;/h3&gt;
&lt;p&gt;三层架构和 MVC 可以结合使用。在这种结合中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;表示层&lt;/strong&gt;通常包含 MVC 的视图和控制器。视图负责显示数据，控制器处理用户输入和调用业务逻辑层。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;业务逻辑层&lt;/strong&gt;对应于 MVC 的模型，处理应用程序的核心逻辑。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数据访问层&lt;/strong&gt;通常不直接包含在 MVC 中，但它为模型提供数据持久化的支持。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通过将三层架构与 MVC 结合，可以构建一个结构清晰、易于维护和扩展的应用程序。&lt;/p&gt;
 ]]></description>
        </item>
    </channel>
</rss>
